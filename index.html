<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create Task</title>

    <script>
        var canvas, boardStartX, boardStartY, boardSizeX, boardSizeY, tiles = {}, hubs = [], megahubs = []
        const citizenChance = 1/3
        var tileCountX = 0
        var tileCountY = 0
        const tileSize = 10
        const familySize = 4
        const infectionChance = 1/10
        const leaveHomeOdds = 1/100
        const tileOutlineSize = tileSize/25
        const boardOutlineSize = 25
        const homeOdds = 1/10
        const hubOdds = 1/100
        const megaHubOdds = 1/1000
        const boardColor = "white"
        function init () {
            console.log('Initializing')
            canvas = document.querySelector('canvas')
            width = canvas.width = window.innerWidth - 100
            height = canvas.height = window.innerHeight - 109
            ctx = canvas.getContext("2d")
            ctx.fillStyle = 'grey'
            ctx.fillRect(0,0,width,height)


            initBoard() 
        }

        function initBoard () {
            console.log("Init. Board")
            //so that the board perfectly fits the tiles and is aligned within the canvas
            boardStartX = (width % tileSize) / 2
            boardStartY = (height % tileSize) / 2
            boardSizeX = width - (boardStartX * 2) 
            boardSizeY = height - (boardStartY * 2)
    



            //next step
            initTiles()
        }


        function initTiles() {
            console.log("Init. Tiles")
            //generate board tiles
            for (let i = 0; i < boardSizeX / tileSize; i++) {
                tileCountX = i
                for (let n = 0; n < boardSizeY / tileSize; n++) {
                    tileCountY = n
                    tiles[i.toString() + "," + n.toString()] = {"x": i, "y": n, "has": "empty", "healthy": 0, "infected": 0}
       
                }
            }

            //populate tiles
            let patientZero = false
            for (const tileKey in tiles) {
                if (patientZero === false) {
                    tiles[tileKey].infected=1
                    console.log(tiles[tileKey])
                    patientZero = true
                }
                if (Math.random() < citizenChance) {
                    tiles[tileKey].healthy++
                }
            }

            // for (let i = 0; i < tiles.length; i++) {
            //     if (tiles[i].)
            // }

            //begin game loop
            console.log('Begin Game Loop')
            // initPOIS()
            gameLoop()
        }


        function gameLoop() {
    
            handleTiles()
            renderBoard()
            renderTiles()
            // renderPOIS()

            //again!
            setTimeout(gameLoop, 100)
        }


        function handleTiles() {
            
            //for each infected citizen in a tile, have a chance to infect one healthy citizen
            for (const tileKey in tiles) {
                let maxIterations = Math.min(tiles[tileKey].healthy, tiles[tileKey].infected)
                // console.log(maxIterations)
                for (let i = 0; i < maxIterations; i++) {
                    if (Math.random() < infectionChance) {
                        tiles[tileKey].healthy--
                        tiles[tileKey].infected++
                    }
                }
            }

            //add functionality to move citizens in a random direction
            
            for (const tileKey in tiles) {
                let roll = "0.99"
                for (let i = 0; i < tiles[tileKey].healthy; i++) {
                    roll = (Math.random()/2.5).toFixed(1)
                    let coords = tileKey.split(",")
                    coords[0] = parseInt(coords[0])
                    coords[1] = parseInt(coords[1])
                    let newKey = false
                    switch (roll) {
                        case "0.0": //direction: -x
                            if (coords[0] - 1 >= 0) { //if it wouldn't leave the board
                                newKey = (coords[0] - 1).toString() + ',' + coords[1].toString()
                            } else {
                                newKey = (coords[0] + 1).toString() + ',' + coords[1].toString()
                            }
                            break
                        case "0.1": //direction +x
                            if (coords[0] + 1 <= tileCountX) { //if it wouldn't leave the board
                                newKey = (coords[0] + 1).toString() + ',' + coords[1].toString()
                            } else {
                                newKey = (coords[0] - 1).toString() + ',' + coords[1].toString()
                            }
                            break
                        case "0.2": //direction -y
                            if (coords[1] - 1 >= 0) { //if it wouldn't leave the board
                                newKey = (coords[0]).toString() + ',' + (coords[1] - 1).toString()
                            } else {
                                newKey = (coords[0]).toString() + ',' + (coords[1] + 1).toString()
                            }
                            break
                        case "0.3": //direction +y
                            if (coords[1] + 1 <= tileCountY) { //if it wouldn't leave the board
                                newKey = (coords[0]).toString() + ',' + (coords[1] + 1).toString()
                            } else {
                                newKey = (coords[0]).toString() + ',' + (coords[1] - 1).toString()
                            }
                            break
                        
                    }
                    
                    if (newKey != false) {
                        tiles[tileKey].healthy--
                        tiles[newKey].healthy++
                    }

                }
                for (let i = 0; i < tiles[tileKey].infected; i++) {
                    roll = (Math.random()/2.5).toFixed(1)
                    let coords = tileKey.split(",")
                    coords[0] = parseInt(coords[0])
                    coords[1] = parseInt(coords[1])
                    let newKey = false
                    switch (roll) {
                        case "0.0": //direction: -x
                            if (coords[0] - 1 >= 0) { //if it wouldn't leave the board
                                newKey = (coords[0] - 1).toString() + ',' + coords[1].toString()
                            } else {
                                newKey = (coords[0] + 1).toString() + ',' + coords[1].toString()
                            }
                            break
                        case "0.1": //direction +x
                            if (coords[0] + 1 <= tileCountX) { //if it wouldn't leave the board
                                newKey = (coords[0] + 1).toString() + ',' + coords[1].toString()
                            } else {
                                newKey = (coords[0] - 1).toString() + ',' + coords[1].toString()
                            }
                            break
                        case "0.2": //direction -y
                            if (coords[1] - 1 >= 0) { //if it wouldn't leave the board
                                newKey = (coords[0]).toString() + ',' + (coords[1] - 1).toString()
                            } else {
                                newKey = (coords[0]).toString() + ',' + (coords[1] + 1).toString()
                            }
                            break
                        case "0.3": //direction +y
                            if (coords[1] + 1 <= tileCountY) { //if it wouldn't leave the board
                                newKey = (coords[0]).toString() + ',' + (coords[1] + 1).toString()
                            } else {
                                newKey = (coords[0]).toString() + ',' + (coords[1] - 1).toString()
                            }
                            break
                        
                    }
                    
                    if (newKey != false) {
                        tiles[tileKey].infected--
                        tiles[newKey].infected++
                    }

                }
            }
        }
        

        function renderBoard() {
            //draw outline aroound board
            ctx.fillStyle = "black"
            ctx.fillRect(boardStartX-boardOutlineSize,boardStartY-boardOutlineSize,boardSizeX+boardOutlineSize*2,boardSizeY+boardOutlineSize * 2)


            ctx.fillStyle = "white"
            ctx.fillRect(boardStartX, boardStartY, boardSizeX, boardSizeY)
     


            //debugging -- draw circles at corners of board
            ctx.fillStyle = "red"
            ctx.beginPath()
            ctx.arc(boardStartX, boardStartY, 5, 0, 2*Math.PI)
            ctx.fill()  
            ctx.fillStyle = "green"
            ctx.beginPath()
            ctx.arc(boardStartX + boardSizeX, boardStartY + boardSizeY, 5, 0, 2*Math.PI)
            ctx.fill()

        }

        function renderTiles() {
            //draw each tile
            // console.log(tiles)
            // for (let i = 0; i < tiles.length; i++) {
            //     let tile = tiles[i]
            //     ctx.fillStyle="black"
            //     ctx.fillRect(boardStartX + (tileSize * tile.x), boardStartY + (tileSize * tile.y), tileSize, tileSize)
            //     ctx.fillStyle="white"
            //     ctx.fillRect(boardStartX + (tileSize * tile.x) + tileOutlineSize, boardStartY + (tileSize * tile.y) + tileOutlineSize, tileSize - tileOutlineSize * 2, tileSize - tileOutlineSize * 2)
            //     ctx.fillStyle="white"   
            // }
        

            //use shade of green background to represent amount of healthy in a tile
            //use growing red circle in center to represent amount of infected in a tile
            for (const tileKey in tiles) {
                let tile = tiles[tileKey]
                ctx.fillStyle="black"
                ctx.fillRect(boardStartX + (tileSize * tile.x), boardStartY + (tileSize * tile.y), tileSize, tileSize)
                ctx.fillStyle="white" 
                ctx.fillRect(boardStartX + (tileSize * tile.x) + tileOutlineSize, boardStartY + (tileSize * tile.y) + tileOutlineSize, tileSize - tileOutlineSize * 2, tileSize - tileOutlineSize * 2)
                ctx.fillStyle="rgba(0,255,0," + (tiles[tileKey].healthy * 0.2).toString() + ")"
                ctx.fillRect(boardStartX + (tileSize * tile.x) + tileOutlineSize, boardStartY + (tileSize * tile.y) + tileOutlineSize, tileSize - tileOutlineSize * 2, tileSize - tileOutlineSize * 2)

                ctx.fillStyle='red'
                ctx.beginPath()
                if (tile.infected > 0) {
                    console.log(tile.infected)
                }
                ctx.arc(boardStartX + (tileSize * tile.x) + tileSize/2 , boardStartY + (tileSize * tile.y) + tileSize/2 , tile.infected * (tileSize / 10), 0, 2*Math.PI)
                ctx.fill()
                
                                
            }
   
        }
        
      
        


        document.addEventListener("DOMContentLoaded", init)

    </script>
</head>
<body>
    <canvas></canvas>
    
</body>
</html>